...................................../Версия 1/.....................................
<unistd.h> - Содержит определения системных символьных констант, а
также прототипы большинства системных вызовов (подключаем для execlp)

pid_t является примитивным типом данных, который определяет идентификатор процесса или группы процессов.

ПРО FORK:
fork возвращает родительскому процессу уникальный идентификатор созданного дочернего процесса.
Процесс-потомок получает в качестве кода возврата значение 0, если вызов fork() оказался успешным.
Если fork возвращает -1, то это свидетельствует об ошибке (естественно, в этом случае возврат происходит только в 
процесс, выполнивший системный вызов).
Дополнительно ядро назначает процессу идентификатор группы процессов (process group ID). 

(Группа процессов включает один или более процессов и
существует, пока в системе присутствует хотя бы один процесс этой группы. Временной интервал, начинающийся 
с создания группы и заканчивающийся, когда последний процесс ее покинет, называется временем
жизни группы. Последний процесс может либо завершить свое выполнение, либо перейти в другую группу)

Новый процесс является точной копией породившего его процесса. Как это ни удивительно, но новый процесс имеет те же 
инструкции и данные, что и его родитель. Более того, выполнение родительского и
дочернего процесса начнется с одной и той же инструкции, следующей за fork(2). Каждый процесс имеет одного родителя, но может
иметь несколько дочерних процессов.

Дочерний процесс наследует у родителя сегменты кода, данных и стека программы, файловые дескрипторы, реальный и эффективный номер 
пользователя и номер группы.

Чем дочерний процесс отличается от родительского?
- дочернему процессу присваивается уникальный идентификатор
- идентификаторы родительского процесса PPID у этих процессов различны
- дочерний процесс свободен от сигналов, ожидающих доставки
- значение, возвращаемое системным вызовом fork(2) различно для родителя и потомка
- (?) израсходованного времени ЦП (оно обнуляется) 

Копируются все структуры данных в ядре и в пространстве пользователя, а значит и таблица открытых файлов.
При выполнении операции fork таблица дескрипторов копируется для дочернего процесса. В результате дочерний процесс 
получает право обращаться к файлам родительского процесса.
В таблице виртуальных Inode во время вызова fork() счётчики числа открытий файлов увеличиваются на количество ссылающихся 
на них файловых дескрипторов нового процесса.
 
Что такое дескриптор файла?
Дескриптор файла - это целое число без знака, с помощью которого процесс обращается к открытому файлу.

Каждый файл имеет связанные с ним метаданные (хранящиеся в индексных дескрипторах — inode), содержащие все характеристики 
файла и позволяющие операционной системе выполнять операции, заказанные прикладной задачей: открыть файл, прочитать или 
записать данные, создать или удалить файл. В частности, метаданные содержат указатели на дисковые блоки хранения данных 
файла. Имя файла в файловой системе является указателем на его метаданные, в то время как метаданные не содержат указателя 
на имя файла.

ПРО EXECLP:

первый аргумент - имя программы, которую нужно испольнить
параметры командной строки
NULL показывает, что аргументы закончились (нужно так как функция с переменным числом аргументов)

execlp подменяет наш машинный код на машинный код cat. Может искать имя программы в переменных среды PATH. 
Если эта переменная не определена, то используется путь поиска ":/bin:/usr/bin" по умолчанию.
После выполнения не создается новый процесс, а образ существующего полностью заменяется на образ, полученный из указанного 
исполняемого файла.

Функции семейства exec* замещают текущий процесс новым, поэтому в случае успеха "возврата" из них 
случиться не может в принципе. Функции exec*() возвращают значение только при возникновении ошибки.

/Из лекции Иртегова/
...

cat - объединяет файл(ы) или поток стандартного ввода и записывает (направляет) на стандартный вывод. 
Её также часто используют для вывода на экран содержимого небольших файлов. 

(Вызов exec("exefile",...) загружает в память существующего процесса код и данные из файла exefile. Все открытые файлы 
сохраняют своё состояние, кроме тех, которые помечены флагом "O_CLOEXEC". Помеченные файлы закрываются. Исполняемый файл 
exefile не занимает файловый дескриптор, но так же считается открытым, 
т.е. exec() увеличивает счётчик числа открытий в таблице виртуальных Inode)







...................................../Версия 2/.....................................
