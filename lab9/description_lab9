...................................../Версия 1/.....................................
<unistd.h> - Содержит определения системных символьных констант, а
также прототипы большинства системных вызовов (подключаем для execlp)

pid_t является примитивным типом данных, который определяет идентификатор процесса или группы процессов.

ПРО FORK:

-> что происходит, когда мы закрываем файл?
-> в родительском сделать malloc, создать дочерний и сделать в родительском free, можно ли будет обращаться к выделенной
памяти в дочернем?
ответ: когда мы будет обращаться к этой памяти, сработает алгоритм copy-on-write и данные скопируются в дочерний процесс =>
=> он будет иметь к ним доступ и сможет изменять.

fork возвращает родительскому процессу уникальный идентификатор созданного дочернего процесса.
У fork() нет параметров.
Процесс-потомок получает в качестве кода возврата значение 0, если вызов fork() оказался успешным.
Если fork возвращает -1, то это свидетельствует об ошибке (естественно, в этом случае возврат происходит только в 
процесс, выполнивший системный вызов). При ошибке устанавливает errno.
Дополнительно ядро назначает процессу идентификатор группы процессов (process group ID). 

copy-on-write (копирование при записи):
сегменты данных и стек скопирование сразу не будут

- Система создает копию страницы при первой модификации
- Немодифицированные страницы остаются разделяемыми
- При обращении к странице на чтение, нормальное обращение
- При обращении на запись как родителем, так и потомком, исключение защиты памяти (GPF у x86)
(!) ОС понимает, что это не настоящая ошибка защиты, и создает копию страницы
Сегменты, отображенные на память с флагом MAP_SHARED остаются разделямыми,
copy-on-write распространяется только на сегменты MAP_PRIVATE и MAP_ANON

(Обычно реализовано через защиту от записи на уровне MMU)


(Группа процессов включает один или более процессов и
существует, пока в системе присутствует хотя бы один процесс этой группы. Временной интервал, начинающийся 
с создания группы и заканчивающийся, когда последний процесс ее покинет, называется временем
жизни группы. Последний процесс может либо завершить свое выполнение, либо перейти в другую группу)

Новый процесс является точной копией породившего его процесса. Как это ни удивительно, но новый процесс имеет те же 
инструкции и данные, что и его родитель. Более того, выполнение родительского и
дочернего процесса начнется с одной и той же инструкции, следующей за fork(2). Каждый процесс имеет одного родителя, но может
иметь несколько дочерних процессов.

Дочерний процесс наследует у родителя сегменты кода, данных и стека программы, файловые дескрипторы, реальный и эффективный номер 
пользователя и номер группы.

Чем дочерний процесс отличается от родительского?
- дочернему процессу присваивается уникальный идентификатор
- идентификаторы родительского процесса PPID у этих процессов различны
- дочерний процесс свободен от сигналов, ожидающих доставки (нити исполнения?)
- значение, возвращаемое системным вызовом fork(2) различно для родителя и потомка
- (?) израсходованного времени ЦП (оно обнуляется) 

Копируются все структуры данных в ядре и в пространстве пользователя, а значит и таблица открытых файлов.
При выполнении операции fork таблица дескрипторов копируется для дочернего процесса. В результате дочерний процесс 
получает право обращаться к файлам родительского процесса.
В таблице виртуальных Inode во время вызова fork() счётчики числа открытий файлов увеличиваются на количество ссылающихся 
на них файловых дескрипторов нового процесса.
 
Что такое дескриптор файла?
Дескриптор файла - это целое число без знака, с помощью которого процесс обращается к открытому файлу.

Каждый файл имеет связанные с ним метаданные (хранящиеся в индексных дескрипторах — inode), содержащие все характеристики 
файла и позволяющие операционной системе выполнять операции, заказанные прикладной задачей: открыть файл, прочитать или 
записать данные, создать или удалить файл. В частности, метаданные содержат указатели на дисковые блоки хранения данных 
файла. Имя файла в файловой системе является указателем на его метаданные, в то время как метаданные не содержат указателя 
на имя файла.

ПРО EXECLP:
-> почему именно execlp?
-> что будет если передать несуществующий файл?
-> где и как ищется первый параметр cat?
-> что конкретно происходит при вызове execlp, чем отличает от fork и почему можем не проверять на ошибку?
fork - создает процесс, а execlp не создает новый процесс, он подменяет машинный код текущей программы, на код cat

- Функции exec* - заменяют исполняющуюся программу в текущем процессе
- exec* сначала проверяет, что файл можно исполнить
- execlp подменяет наш машинный код на машинный код cat. Может искать имя программы в переменных среды PATH. 
- После выполнения не создается новый процесс, а образ* существующего полностью заменяется на образ, полученный из указанного 
исполняемого файла.

* образ процесса - виртуальное адресное пространство процесса во время исполнения.

- Аргументы exec копируются на дно стека.
- Все открытые файлы сохраняют своё состояние, кроме тех, которые помечены флагом "O_CLOEXEC" ("CLOEXEC") (их закрывает ядро)

НЕ наследуются:
– Адресное пространство и отображенные на память файлы
– Пользовательские обработчики сигналов
– Регистры ЦПУ (контекст процесса)
– Нити исполнения
– euid/egid (Эффективный идентификатор пользователя и группы), если исполняемый файл setuid/setgid

//setuid и setgid являются флагами прав доступа в Unix, которые разрешают пользователям запускать исполняемые 
файлы с правами владельца или группы исполняемого файла.

cat - объединяет файл(ы) или поток стандартного ввода и записывает (направляет) на стандартный вывод. 
Её также часто используют для вывода на экран содержимого небольших файлов. 

Параметры:
1. первый параметр - имя программы, которую нужно испольнить - имя файла абсолютное или относительное (бинарный код)
(!) первый аргумент обязан быть и должен совпадать с именем программы.

//Полным, или абсолютным, называется имя файла, содержащее все каталоги до корня файловой системы. 
//Относительные имена файлов не содержат полного пути и обычно привязываются к текущему каталогу.

2. параметры командной строки (тип char*)
3. NULL показывает, что аргументы закончились (нужно так как функция с переменным числом аргументов)

execlp расшифровка:
l - 
p - означает, что ищет тот параметр, который мы передали, в PATH и исполняет первое, что найдет (начинает
искать только если имя не содержит ни одного / (слеша)
если / есть, то ищет в текущем каталоге или от корня, в зависимости от того, где этот /стоит 

Проверки на ошибку нет, т.к. если попадаем в perror - это уже означает ошибку (в текущем процессе наша программа не заменилась
на cat).

(Вызов exec("exefile",...) загружает в память существующего процесса код и данные из файла exefile. Исполняемый файл 
exefile не занимает файловый дескриптор, но так же считается открытым, 
т.е. exec() увеличивает счётчик числа открытий в таблице виртуальных Inode)

...................................../Версия 2/.....................................
