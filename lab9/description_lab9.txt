...................................../Версия 1/.....................................

-> Может ли быть такое, что фраза из родительского процесса выведется после дочернего?
ответ: да, если текст будет большой.

-> Почему приглашение командного интерпретатора shell появилось в середине строки вывода?
ответ: потому что родительский процесс завершился раньше порожденного, а shell выдает приглашение при завершении родительского процесса, не
ожидая завершения его подпроцессов.

-> что произойдет, если родительский процесс завершится раньше дочернего?
ответ: Родителем любого процесса, родительский процесс которого завершился раньше его самого, становится процесс init. 
В таком случае мы говорим, что процесс был унаследован процессом init. Обычно при завершении какого-либо процесса ядро проверяет 
все активные процессы, чтобы узнать, не является ли завершившийся процесс чьим-либо родителем. Если это так, для процесса, 
оставшегося активным, идентифи-катором родительского процесса назначается 1 (идентификатор процесса init). 
Благодаря этому удается гарантировать наличие родителя у любого процесса.

-> что произойдет, если дочерний процесс заканчивает работу раньше родительского?
ответ: Ядро сохраняет некоторый объем информации о каждом завершившемся процессе, чтобы она была доступна, когда родительский процесс 
вызовет функцию wait или waitpid. В простейшем случае эта информация состоит из идентификатора процесса, кода завершения и количества 
процессорного времени, затраченного процессом. Ядро может освободить всю память, занимаемую процессом, и закрыть его открытые файлы. 
В терминологии UNIX процесс, который завершился, но при этом его родительский процесс не уловил этого момента, называют ЗОМБИ. 

-> что происходит, когда заканчивается процесс, унаследованный процессом init?
ответ: он не превращается в зомби, потому что init создан так, что всякий раз, когда один из его потомков завершается, init вызывает одну из функций wait, чтобы забрать код завершения. Таким способом init препятствует засорению системы процессами-зомби.

-> в родительском сделать malloc, создать дочерний и сделать в родительском free, можно ли будет обращаться к выделенной
памяти в дочернем?
ответ: когда мы будет обращаться к этой памяти, сработает алгоритм copy-on-write и данные скопируются в дочерний процесс =>
=> он будет иметь к ним доступ и сможет изменять.

<unistd.h> - Содержит определения системных символьных констант, а
также прототипы большинства системных вызовов (подключаем для execlp)

pid_t является примитивным типом данных, который определяет идентификатор процесса или группы процессов.

ПРО FORK:
Системный вызов fork создает процесс. У fork() нет параметров.
Эта функция вызывается один раз, а управление возвращает дважды, с единственным отличием: в дочернем процессе она возвращает 0, а в родительском — идентификатор созданного дочернего процесса, в случае успеха.

Если fork возвращает -1, то это свидетельствует об ошибке (естественно, в этом случае возврат происходит только в 
процесс, выполнивший системный вызов). При ошибке устанавливает errno.

-> когда fork может завершиться ошибкой?
. закончилась административная квота на число процессов 
   (!) максимальное количество одновременно работающих процессов на один реальный идентификатор пользователя определяется константой CHILD_MAX.
. у системы не хватает памяти ядра, чтобы создать новый процесс (редко, но бывает)
. нет полномочий исполнять fork
 
Дополнительно ядро назначает процессу идентификатор группы процессов (process group ID). 

Новый процесс является точной копией породившего его процесса. Новый процесс имеет те же 
инструкции и данные, что и его родитель. Каждый процесс имеет одного родителя, но может
иметь несколько дочерних процессов.

Дочерний процесс наследует у родителя сегменты кода, данных и стека программы, файловые дескрипторы, реальный и эффективный номер 
пользователя и номер группы.

Дочерний процесс не наследует:
- pid - идентификатор
- ppid - идентификатор родительского процесса 
- Захваченные участки файлов
- Нити исполнения (кроме той, которая вызывала fork) - т.е. когда сделаем fork многопоточного процесса, у него наследуется
только та нить, которая сделала fork

copy-on-write (копирование при записи):
Сегменты данных и стек скопирование сразу не будут, изначально, они являются разделяемыми. 
При обращении к странице на чтение, нормальное обращение.

(!) При обращении на запись как родителем, так и потомком, происходит исключение защиты памяти (GPF у x86):
система ставит защиту от записи на все страницы, если мы пытаемся модифицировать какую то переменную, 
то прилетает ошибка диспетчера памяти, обработчик этой ошибки в ядре ОС смотрит, что это не настоящая защита от записи, 
а copy-on-write, и он дублирует страницу и отдает ее родительскому или дочернему процессу.

- Сегменты, отображенные на память с флагом MAP_SHARED остаются разделямыми,
copy-on-write распространяется только на сегменты MAP_PRIVATE и MAP_ANON
т.е. будет ли copy-on-write определяется флагами, с которыми этот сегмент создавался!

Атрибуты процесса в ядре по-честному копируются, для них нет copy-on-write (нужно для корректной работы ядра ОС)

ПРО ФАЙЛОВЫЕ ДЕСКРИПТОРЫ:
(!) Что такое дескриптор файла?
Дескриптор файла - это целое число без знака, с помощью которого процесс обращается к открытому файлу.

Копируются все структуры данных в ядре и в пространстве пользователя, а значит и таблица открытых файлов.
При выполнении операции fork таблица дескрипторов копируется для дочернего процесса. В результате дочерний процесс 
получает право обращаться к файлам родительского процесса.
В таблице виртуальных Inode во время вызова fork() счётчики числа открытий файлов увеличиваются на количество ссылающихся 
на них файловых дескрипторов нового процесса.

Таблица файловых дескрипторов индексирует общесистемную таблицу файлов, открытых всеми процессами. 
В таблице файлов записывается режим, в котором открыт файл или другой ресурс — например, для чтения, записи, чтения и записи.

-> структура файла остается общей, поэтому, например, если сделать lseek файла в дочернем процессе, то родительский процесс
это тоже видит (lseek - передвижение указателя чтения/записи).
-> чтобы закрыть файл, надо закрыть его во всех процессах

/*
Порожденный процесс является точной копией процесса, выполнившего этот вызов. В частности, дочерний процесс наследует такие атрибуты родителя, как:
- идентификаторы пользователя и группы,
- переменные окружения,
- диспозицию сигналов и их обработчики,
- ограничения, накладываемые на процесс,
- текущий и корневой каталог,
- маску создания файлов,
- все файловые дескрипторы, включая файловые указатели,
- управляющий терминал.
*/

ПРО EXECLP:
если у exec* нет буквы e в конце, то среда копируется

-> почему именно execlp?
см. расшифровку.
-> что будет если передать несуществующий файл? 
cat: cannot open text1.txt: No such file or directory

-> что конкретно происходит при вызове execlp, чем отличает от fork и почему можем не проверять на ошибку?
fork - создает процесс, а execlp не создает новый процесс, он подменяет машинный код текущей программы, на код cat
............................................................................................................................
- Функции exec* - заменяют исполняющуюся программу в текущем процессе

- exec* сначала проверяет, что файл можно исполнить

- execlp подменяет наш машинный код на машинный код cat (cat - объединяет файл(ы) или поток стандартного ввода и записывает (направляет) на стандартный вывод. 
Её также часто используют для вывода на экран содержимого небольших файлов)

- После выполнения не создается новый процесс, а образ* существующего полностью заменяется на образ, полученный из указанного 
исполняемого файла.

* образ процесса - виртуальное адресное пространство процесса во время исполнения.
...........................................................................................................................

Наследуется:
- Все открытые файлы сохраняют своё состояние, кроме тех, которые помечены флагом "O_CLOEXEC" ("CLOEXEC") (их закрывает ядро)
- Почти все содержимое User Area 
- Захваченные участки файлов
- euid/egid (Эффективный идентификатор пользователя и группы), если исполняемый файл НЕ setuid/setgid

НЕ наследуются:
– Адресное пространство и отображенные на память файлы
– Пользовательские обработчики сигналов
– Регистры ЦПУ (контекст процесса)
– Нити исполнения
– euid/egid (Эффективный идентификатор пользователя и группы), если исполняемый файл setuid/setgid (setuid и setgid являются флагами прав доступа в Unix, которые разрешают пользователям запускать исполняемые файлы с правами владельца или группы исполняемого файла).

Параметры:
1. первый параметр - имя программы, которую нужно испольнить - имя файла абсолютное или относительное (бинарный код)
(!) (!) argv[0] (первый аргумент командной строки) должно совпадать с первым аргументом exec, т.к. в UNIX довольно много программ, которые решают что им делать
в зависимости от того под каким именем их позвали и если сделать их разными может исполнится вообще другая программа.
.................................................................................................
//Полным, или абсолютным, называется имя файла, содержащее все каталоги до корня файловой системы. 
//Относительные имена файлов не содержат полного пути и обычно привязываются к текущему каталогу.
.................................................................................................
2. параметры командной строки (тип char*)
3. NULL показывает, что аргументы закончились (нужно так как функция с переменным числом аргументов)

execlp расшифровка:
l - аргументы передаются просто как отдельные аргументы типа char (используется, если число аргументов нам заранее известно)
p - означает, что ищет исполняемый в PATH и исполняет первое, что найдет (начинает
искать только если имя не содержит ни одного / (слеша))

если / есть, то ищет в текущем каталоге (какой он? хранится в переменной среды PWD (?)) или от корня, в зависимости от того, где этот / стоит;

HOME - домашняя директория текущего пользователя
PWD - текущая директория 

Проверки на ошибку нет, т.к. если попадаем в perror - это уже означает ошибку (в текущем процессе наша программа не заменилась
на cat).

Если execlp завершился успехом, то всё текущее адресное пространство заменяется на адресное пространство, созданное
на основе бинарного файла, который мы передали первым параметром и запускается новая программа.
Аргументы execlp копируются на дно стека.
Содержимое User Area у процесса почти не меняется, т.е. все файлы остаются открытыми.

(Вызов exec("exefile",...) загружает в память существующего процесса код и данные из файла exefile. Исполняемый файл 
exefile не занимает файловый дескриптор, но так же считается открытым, 
т.е. exec() увеличивает счётчик числа открытий в таблице виртуальных Inode)

...................................../Версия 2/.....................................

ПРО WAIT:
Операционная система предоставляет процессу ряд функций, позволяющих ему контролировать выполнение потомков. 
pid_t wait(int *stat_loc);
wait  позволяет заблокировать выполнение процесса, пока кто-либо из его непосредственных потомков не прекратит существование.
Если в аргументе передается непустой указатель, по заданному адресу будет записан код завершения дочернего процесса. 
Если код завершения нас не интересует, можно передать в этом аргументе пустой указатель.

УСПЕХ- идентификатор завершившегося подпроцесса и в stat_loc кладется код возврата, в виде:
|             |параметр exit|номер сигнала|
* в младшем байте лежит номер сигнала или 0, если процесс завершился не по сигналу
* если в младшем байте 0, то во втором байте лежит код возврата
.........................................................................................................
чтобы достать код возврата, есть несколько макросов:
WIFEXITED(stat) - ненулевое значение, если подпроцесс нормально завершился
WEXITSTATUS(stat) - код завершения подпроцесса
WIFSIGNALED(stat) - ненулевое значение, если подпроцесс был принудительно завершен сигналом
WTERMSIG(stat) - номер сигнала, который вызвал завершение подпроцесса
WCOREDUMP(stat) если WIFSIGNALED - не ноль, то возвращает ненулевое значение, если был создан образ ядра 
.........................................................................................................
НЕУСПЕХ - (-1) и errno установлена
-> Возвращает значение -1, если wait был прерван сигналом. 
-> если у процесса нет потомков, wait сразу возвращает ошибку ECHILD!

Возвращает управление немедленно, если существует подпроцесс, который уже завершился, но к нему не применялся wait. 
В этом случае также возвращается индентификатор подпроцесса.










***СИГНАЛЫ:
Сигнал является способом передачи уведомления о некотором произошедшем событии между процессами или между ядром системы и процессами. 
Сигналы можно рассматривать, как простейшую форму межпроцессного взаимодействия, хотя на самом деле они больше напоминают
программные прерывания, при которых нарушается нормальное выполнение процесса.

Прежде всего, каждый сигнал имеет уникальное символьное имя и соответствующий ему номер.

(!) Например, сигнал прерывания, посылаемый процессу при нажатии пользователем клавиши <Del> или <Ctrl>+<C>, имеет имя SIGINT.

Сигнал может быть отправлен процессу либо ядром, либо другим процессом с помощью системного вызова kill(2).
