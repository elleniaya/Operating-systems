...................................../Версия 1/.....................................
<unistd.h> - Содержит определения системных символьных констант, а
также прототипы большинства системных вызовов (подключаем для execlp)

pid_t является примитивным типом данных, который определяет идентификатор процесса или группы процессов.

ПРО FORK:

-> что происходит, когда мы закрываем файл?
-> в родительском сделать malloc, создать дочерний и сделать в родительском free, можно ли будет обращаться к выделенной
памяти в дочернем?
ответ: когда мы будет обращаться к этой памяти, сработает алгоритм copy-on-write и данные скопируются в дочерний процесс =>
=> он будет иметь к ним доступ и сможет изменять.

fork возвращает родительскому процессу уникальный идентификатор созданного дочернего процесса.
У fork() нет параметров.
Процесс-потомок получает в качестве кода возврата значение 0, если вызов fork() оказался успешным.
Если fork возвращает -1, то это свидетельствует об ошибке (естественно, в этом случае возврат происходит только в 
процесс, выполнивший системный вызов). При ошибке устанавливает errno.

-> когда fork может завершиться ошибкой?
. закончилась административная квота на число процессов
. у системы не хватает памяти ядра, чтобы создать новый процесс (редко, но бывает)
. нет полномочий исполнять fork
 
Дополнительно ядро назначает процессу идентификатор группы процессов (process group ID). 

copy-on-write (копирование при записи):
сегменты данных и стек скопирование сразу не будут

- Система создает копию страницы при первой модификации
- Немодифицированные страницы остаются разделяемыми
- При обращении к странице на чтение, нормальное обращение
- При обращении на запись как родителем, так и потомком, исключение защиты памяти (GPF у x86) (система ставит защиту от записи 
на все страницы, если мы пытаемся модифицировать какую то переменную, то прилетает ошибка диспетчера памяти, 
обработчик этой ошибки в ядре ОС смотрит, что это не настоящая защита от записи, а copy-on-write, и он дублирует страницу
и отдает ее родительскому или дочернему процессу.
- Сегменты, отображенные на память с флагом MAP_SHARED остаются разделямыми,
copy-on-write распространяется только на сегменты MAP_PRIVATE и MAP_ANON

т.е. будет ли copy-on-write определяется флагами, с которыми этот сегмент создавался!

(Группа процессов включает один или более процессов и
существует, пока в системе присутствует хотя бы один процесс этой группы. Временной интервал, начинающийся 
с создания группы и заканчивающийся, когда последний процесс ее покинет, называется временем
жизни группы. Последний процесс может либо завершить свое выполнение, либо перейти в другую группу)

Новый процесс является точной копией породившего его процесса. Новый процесс имеет те же 
инструкции и данные, что и его родитель. Более того, выполнение родительского и
дочернего процесса начнется с одной и той же инструкции, следующей за fork(). Каждый процесс имеет одного родителя, но может
иметь несколько дочерних процессов.

Дочерний процесс наследует у родителя сегменты кода, данных и стека программы, файловые дескрипторы, реальный и эффективный номер 
пользователя и номер группы.

Атрибуты процесса в ядре по-честному копируются, для них нет copy-on-write (нужно для корректной работы ядра ОС)

Дочерний процесс не наследует:
- pid 
- ppid 
- Захваченные участки файлов
- Нити исполнения (кроме той, которая вызывала fork) - т.е. когда сделаем fork многопоточного процесса, у него наследуется
только та нить, которая сделала fork

Чем дочерний процесс отличается от родительского?
- дочернему процессу присваивается уникальный идентификатор
- идентификаторы родительского процесса PPID у этих процессов различны
- дочерний процесс свободен от сигналов, ожидающих доставки (нити исполнения?)
- значение, возвращаемое системным вызовом fork(2) различно для родителя и потомка
- (?) израсходованного времени ЦП (оно обнуляется) 

ПРО ФАЙЛОВЫЕ ДЕСКРИПТОРЫ:
(!) Что такое дескриптор файла?
Дескриптор файла - это целое число без знака, с помощью которого процесс обращается к открытому файлу.

Копируются все структуры данных в ядре и в пространстве пользователя, а значит и таблица открытых файлов.
При выполнении операции fork таблица дескрипторов копируется для дочернего процесса. В результате дочерний процесс 
получает право обращаться к файлам родительского процесса.
В таблице виртуальных Inode во время вызова fork() счётчики числа открытий файлов увеличиваются на количество ссылающихся 
на них файловых дескрипторов нового процесса.

-> структура файла остается общей, поэтому, например, если сделать lseek файла в дочернем процессе, то родительский процесс
это тоже видит
-> чтобы закрыть файл, надо закрыть его во всех процессах

Каждый файл имеет связанные с ним метаданные (хранящиеся в индексных дескрипторах — inode), содержащие все характеристики 
файла и позволяющие операционной системе выполнять операции, заказанные прикладной задачей: открыть файл, прочитать или 
записать данные, создать или удалить файл. В частности, метаданные содержат указатели на дисковые блоки хранения данных 
файла. Имя файла в файловой системе является указателем на его метаданные, в то время как метаданные не содержат указателя 
на имя файла.

/*
Порожденный процесс является точной копией процесса, выполнившего этот вызов. В частности, дочерний процесс наследует такие атрибуты родителя, как:
- идентификаторы пользователя и группы,
- переменные окружения,
- диспозицию сигналов и их обработчики,
- ограничения, накладываемые на процесс,
- текущий и корневой каталог,
- маску создания файлов,
- все файловые дескрипторы, включая файловые указатели,
- управляющий терминал.
*/

ПРО EXECLP:
если у exec* нет буквы e в конце, то среда копируется
(!)argv[0] должно совпадать с первым аргументом exec, т.к. в UNIX довольно много программ, которые решают что им делать
в зависимости от того под каким именем их позвали и если сделать их разными может исполнится вообще доугая программа

-> почему именно execlp?
-> что будет если передать несуществующий файл?
-> где и как ищется первый параметр cat?
-> что конкретно происходит при вызове execlp, чем отличает от fork и почему можем не проверять на ошибку?
fork - создает процесс, а execlp не создает новый процесс, он подменяет машинный код текущей программы, на код cat

- Функции exec* - заменяют исполняющуюся программу в текущем процессе
- exec* сначала проверяет, что файл можно исполнить
- execlp подменяет наш машинный код на машинный код cat. Может искать имя программы в переменных среды PATH. 
- После выполнения не создается новый процесс, а образ* существующего полностью заменяется на образ, полученный из указанного 
исполняемого файла.

* образ процесса - виртуальное адресное пространство процесса во время исполнения.

Наследуется:
- Все открытые файлы сохраняют своё состояние, кроме тех, которые помечены флагом "O_CLOEXEC" ("CLOEXEC") (их закрывает ядро)
- Почти все содержимое User Area 
- Захваченные участки файлов
- euid/egid (Эффективный идентификатор пользователя и группы), если исполняемый файл НЕ setuid/setgid

НЕ наследуются:
– Адресное пространство и отображенные на память файлы
– Пользовательские обработчики сигналов
– Регистры ЦПУ (контекст процесса)
– Нити исполнения
– euid/egid (Эффективный идентификатор пользователя и группы), если исполняемый файл setuid/setgid

//setuid и setgid являются флагами прав доступа в Unix, которые разрешают пользователям запускать исполняемые 
файлы с правами владельца или группы исполняемого файла.

cat - объединяет файл(ы) или поток стандартного ввода и записывает (направляет) на стандартный вывод. 
Её также часто используют для вывода на экран содержимого небольших файлов. 

Параметры:
1. первый параметр - имя программы, которую нужно испольнить - имя файла абсолютное или относительное (бинарный код)
(!) первый аргумент обязан быть и должен совпадать с именем программы.

//Полным, или абсолютным, называется имя файла, содержащее все каталоги до корня файловой системы. 
//Относительные имена файлов не содержат полного пути и обычно привязываются к текущему каталогу.

2. параметры командной строки (тип char*)
3. NULL показывает, что аргументы закончились (нужно так как функция с переменным числом аргументов)

execlp расшифровка:
l - аргументы передаются просто как отдельные аргументы типа char (используется, если число аргументов нам заранее известно)
p - означает, что ищет тот параметр, который мы передали, в PATH и исполняет первое, что найдет (начинает
искать только если имя не содержит ни одного / (слеша))
если / есть, то ищет в текущем каталоге или от корня, в зависимости от того, где этот /стоит 

Проверки на ошибку нет, т.к. если попадаем в perror - это уже означает ошибку (в текущем процессе наша программа не заменилась
на cat).

Если execlp завершился успехом, то всё текущее адресное пространство заменяется на адресное пространство, созданное
на основе бинарного файла, который мы передали первым параметром и запускается новая программа.
Аргументы exec копируются на дно стека.
Содержимое User Area у процесса почти не меняется, т.е. все файлы остаются открытыми.

(Вызов exec("exefile",...) загружает в память существующего процесса код и данные из файла exefile. Исполняемый файл 
exefile не занимает файловый дескриптор, но так же считается открытым, 
т.е. exec() увеличивает счётчик числа открытий в таблице виртуальных Inode)

...................................../Версия 2/.....................................
