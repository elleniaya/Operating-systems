СИГНАЛЫ:
Сигналы являются способом передачи от одного процесса другому или от ядра операционной системы какому!либо процессу уведомления о возникновении определенного события. Сигналы можно рассматривать как простейшую форму межпроцессного взаимодействия. В то же время сигналы больше напоминают программные прерывания, — средство, с помощью
которого нормальное выполнение процесса может быть прервано.

-> Каждый сигнал имеет уникальное символьное имя и соответствующий ему номер. Например, сигнал прерывания, посылаемый процессу при нажатии пользователем 
клавиши <Del> или <Ctrl>+<C>, имеет имя SIGINT.

-> Сигнал, генерируемый комбинацией <Ctrl>+<\>, называется SIGQUIT.

Администратор системы может посылать (с помощью kill) сигналы любым процессам, обычный же пользователь
может посылать сигналы только процессам, владельцем которых он является.

..............................................................
К генерации сигнала могут привести различные ситуации:
1. Ядро отправляет процессу (или группе процессов) сигнал при нажатии пользователем определенных клавиш или их комбинаций.
2. Аппаратные особые ситуации, например, деление на 0, обращение к недопустимой области памяти и т. д., также вызывают генерацию сигнала.
(Обычно эти ситуации определяются аппаратурой компьютера, и ядру посылается соответствующее уведомление (например, в виде прерывания). Ядро реагирует на это отправкой соответствующего сигнала процессу, который находился в стадии выполнения, когда произошла особая ситуация.)
3. Определенные программные состояния системы или ее компонентов также могут вызвать отправку сигнала.
(В качестве примера можно привести сигнал SIGALRM, отправляемый процессу, когда срабатывает таймер, ранее установленный с помощью вызова alarm)

Доставка сигнала происходит после того, как ядро от имени процесса вызывает системную процедуру issig() которая проверяет, существуют ли
ожидающие доставки сигналы, адресованные данному процессу. Функция issig вызывается ядром в трех случаях:
1. Непосредственно перед возвращением из режима ядра в режим задачи после обработки системного вызова или прерывания.
2. Непосредственно перед переходом процесса в состояние сна с приоритетом, допускающим прерывание сигналом.
3. Сразу же после пробуждения после сна с приоритетом, допускающим прерывание сигналом.

Если процедура () обнаруживает ожидающие доставки сигналы, ядро вызывает функцию доставки сигнала, которая выполняет действия по
умолчанию или вызывает специальную функцию sendsig(), запускающую обработчик сигнала, зарегистрированный процессом.
Функция sendsig() возвращает процесс в режим задачи, передает управление обработчику сигнала, а затем восстанавливает контекст процесса для продолжения 
прерванного сигналом выполнения.
..............................................................

При получении сигнала процесс имеет три варианта действий для выбора:
1. Проигнорировать. 
2. Процесс может потребовать действия по умолчанию. Обычно это сводится к завершению выполнения процесса.
3. Перехватить сигнал. 

-> Для каждого сигнала в системе определена обработка по умолчанию, которую выполняет ядро, если процесс не указал другого действия.

(!) Сигналы SIGKILL и SIGSTOP нельзя ни перехватить, ни игнорировать.
..............................................................

ЧТО ПРОИСХОДИТ, КОГДА МЫ НАЖИМАЕМ <Ctrl>+<C>:
1. Нажатие любой клавиши вызывает аппаратное прерывание.
2. Драйвер терминала при обработке этого прерывания определяет, что была нажата специальная клавиша, генерирующая сигнал, и отправляет текущему процессу, 
связанному с терминалом, сигнал SIGINT.
3. Когда процесс будет выбран планировщиком и запущен на выполнение, при переходе в режим задачи он обнаружит поступление сигнала и обработает его.
4. Если же в момент генерации сигнала терминальным драйвером процесс, которому был адресован сигнал, уже выполнялся (т. е. был прерван обработчиком терминального прерывания), он также обработает сигнал при возврате в режим задачи после обработки прерывания.

ОСОБЫЕ СИТУАЦИИ (деление на ноль и т.п.): похоже на описанное выше:
Вызывается системный обработчик особой ситуации, и процесс переходит в режим ядра, почти так же, как и при обработке любого другого прерывания. Обработчик 
отправляет процессу соответствующий сигнал, который доставляется, когда выполнение возвращается в режим задачи.

ФУНКЦИЯ SIGSET:
Изменяет обработку сигнала sig.
-> аргументы:
sig - номер сигнала
disp - функция обработчика сигнала

При успешном выполнении sigset() возвращает SIG_HOLD, если sig был заблокирован до вызова, или предыдущий обработчик сигнала, если блокировки не было. При ошибке sigset() возвращает -1, а errno записывает номер ошибки 



