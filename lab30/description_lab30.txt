Сокеты создаются в рамках определенного коммуникационного домена, подобно тому как файлы создаются в рамках
файловой системы. Сокеты имеют соответствующий интерфейс доступа в файловой системе UNIX, и так же как обычные файлы, адресуются некоторым целым числом — дескриптором.
Однако в отличие от обычных файлов, сокеты представляют собой виртуальный объект, который существует, пока на него ссылается хотя бы один из процессов.

Приложение должно иметь возможность затребовать определенный тип связи, например, основанный на виртуальном канале (virtual circuit) или датаграммах (datagram), 
причем эти типы должны быть согласованы для всех коммуникационных доменов. Все сокеты условно можно разделить на несколько типов, в зависимости от предоставляемых 
коммуникационных характеристик. Полный набор этих характеристик включает:
1. Упорядоченную доставку данных
2. Отсутствие дублирования данных
3. Надежную доставку данных
4. Сохранение границ сообщений
5. Поддержку передачи экстренных сообщений
6. Предварительное установление соединения

В BSD UNIX реализованы следующие основные типы сокетов:
-> Сокет датаграмм - через который осуществляется теоретически ненадежная, несвязная передача пакетов.
-> Сокет потока - через который осуществляется надежная передача потока байтов без сохранения границ сообщений. Этот тип сокетов поддерживает передачу экстренных данных.
-> Сокет пакетов - через который осуществляется надежная последовательная передача данных без дублирования с предварительным установлением связи. При этом сохраняются
границы сообщений.
-> Сокет низкого уровня - через который осуществляется непосредственный доступ к коммуникационному протоколу.

Наконец, для того чтобы независимые процессы имели возможность взаимодействовать друг с другом, для сокетов должно быть определено пространство имен. Имя сокета 
имеет смысл только в рамках коммуникационного домена, в котором он создан.

Для создания сокета процесс должен указать тип сокета и коммуникационный домен, в рамках которого будет использоваться сокет.

Поскольку коммуникационный домен может поддерживать использование нескольких протоколов, процесс может также указать конкретный коммуникационный
протокол для взаимодействия. Если таковой не указан, система выберет наиболее подходящий из списка протоколов, доступных для данного коммуникационного домена. 
Если же в рамках указанного домена создание сокета данного типа невозможно, т. е. отсутствует соответствующий коммуникационный протокол, запрос процесса завершится
неудачно.

SERVER:

-> unlink - утилита Unix, удаляющая имя одного указанного файла из файловой системы.
Если путь именуется символической ссылкой, unlink () должен удалить символическую ссылку, указанную путем , и не должен влиять ни на один файл или каталог, 
названный содержимым символической ссылки. В противном случае unlink () удалит ссылку, указанную путем, на который указывает path , и уменьшит счетчик ссылок 
файла, на который ссылается ссылка.

Для внутреннего домена UNIX адрес выглядит следующим образом (определен в #include <sys/un.h>)
struct sockaddr_un {
    short sun_family /* == AF_UNIX */
    char sun_path[108]
}

Поле sa_family определяет коммуникационный домен (семейство протоколов), а sun_path содержит собственно адрес, формат которого определен для каждого домена.
Поскольку в данном домене взаимодействующие процессы выполняются под управлением одной операционной системы на одном и том же хосте,
коммуникационный узел может быть однозначно определен одним параметром — локальным процессом. В качестве адреса в домене UNIX используются имена файлов.

СИСТЕМНЫЙ ВЫЗОВ BIND:
УСПЕХ: 0
НЕУСПЕХ: -1
Cвязывание необходимо для присвоения сокету локального адреса и, таким образом, для определения коммуникационного узла. Можно выделить три случая использования 
для этого функции bind:
1. Сервер регистрирует свой адрес. Этот адрес должен быть заранее известен клиентам, желающим "общаться" с сервером. Связывание необходимо, прежде чем сервер 
будет готов к приему запросов от клиентов.
2. При взаимодействии без предварительного установления связи и создания виртуального канала клиент также должен предварительно зарегистрировать свой адрес. 
Этот адрес должен быть уникальным в рамках коммуникационного домена. В случае домена UNIX об этом должно позаботиться само приложение. Этот адрес не должен быть 
заранее известен серверу, поскольку запрос всегда инициирует клиент, автоматически передавая вместе с ним свой адрес. Полученный адрес
удаленного узла затем используется сервером для мультиплексирования сообщений, отправляемым различным клиентам.
3. Даже в случае взаимодействия с использованием виртуального канала клиент может пожелать зарегистрировать собственный адрес, не полагаясь при этом на систему.

НЕМНОГО ПРО Unix domain sockets:
(!) Unix domain sockets использует только SOCK_STREAM.
(!) Право на присоединение регулируется правами доступа к файлу
(!) После завершения сервера, файл сокета сам не удаляется
(!) Это может помешать повторному bind(3SOCKET)
(!) Надо использовать unlink


-> СИСТЕМНЫЙ ВЫЗОВ SOCKET:
int socket (int domain, int type, int protocol);
Здесь аргумент domain определяет коммуникационный домен, type — тип
сокета, a protocol — используемый протокол (может быть не указан, т. е. приравнен 0).
(!) По умолчанию сокет типа SOCK_STREAM будет использовать протокол TCP,  а сокет типа SOCK_DGRAM – протокол UDP.
НЕУСПЕХ: -1 
УСПЕХ:  положительное целое число, аналогичное файловому дескриптору, которое служит для адресации данного сокета в последующих вызовах.
Возможные значения аргумента domain включают:
-> AF_UNIX - Домен локального межпроцессного взаимодействия в пределах единой операционной системы UNIX. Внутренние протоколы.
-> AF_INET - Домен взаимодействия процессов удаленных систем. Протоколы Internet (TCP/IP).
-> AF_NS - Домен взаимодействия процессов удаленных систем. Протоколы Xerox NS.
AF - от address family — семейство адресов (Поскольку домен и семейство протоколов определяют адресное пространство взаимодействия).

Следующие два вызова используются сервером только при взаимодействии, основанном на предварительном создании виртуального канала между сервером и клиентом.
-> СИСТЕМНЫЙ ВЫЗОВ LISTEN:
Системный вызов listen(2) информирует систему, что сервер готов принимать запросы. Он имеет следующий вид:
int listen (int sockfd, int backlog);
Здесь параметр sockfd определяет сокет, который будет использоваться для получения запросов. Предполагается, что сокет был предварительно
связан с известным адресом. Параметр backlog указывает максимальное число запросов на установление связи, которые могут ожидать обработки сервером.
После заполнения очереди система будет отвергать дополнительные запросы на соединение. 

-> СИСТЕМНЫЙ ВЫЗОВ ACCEPT:
int accept(int sockfd, struct sockaddr *address, size_t *add_len)
Функция accept возвращает дескриптор сокета, соединенного с клиентом, вызвавшим функцию connect. 
Системному вызову accept передается дескриптор сокета, для которого ведется прием соединений. 
Параметр address заполняется информацией о клиенте. Так как связь использует соединение, адрес клиента
знать не обязательно, поэтому можно присвоить параметру address значение NULL. 
Если значение address не равно NULL, то переменная, на которую указывает параметр add_len, 
первоначально должна содержать размер структуры адреса, заданной параметром address. 

Фактическую обработку запроса клиента на установление связи производит системный вызов accept.
Вызов accept(2) извлекает первый запрос из очереди и создает новый сокет, характеристики которого не отличаются от сокета sockfd, и таким
образом завершает создание виртуального канала со стороны сервера. Одновременно accept(2) возвращает параметры удаленного коммуникационного узла — адрес 
клиента clntaddr и его размер addrlen. Новый сокет используется для обслуживания созданного виртуального канала, а полученный адрес клиента исключает 
анонимность последнего.

В этом сценарии, в то время как дочерний процесс обеспечивает фактический обмен данными с клиентом, родительский процесс продолжает
"прослушивать" поступающие запросы, порождая для каждого из них отдельный процесс-обработчик. Очередь позволяет буферизировать запросы
на время, пока сервер завершает вызов accept(2) и затем создает дочерний процесс. Заметим, что новый сокет newsockfd, полученный в результате
вызова accept(2), адресует полностью определенный коммуникационный канал: протокол и полные адреса обоих узлов — клиента и сервера. Напротив, для сокета 
sockfd определена только локальная часть канала. Это позволяет серверу продолжать использовать sockfd для "прослушивания" последующих запросов.

-> 42 строка - Поскольку адрес в домене UNIX представляет собой имя файла, который будет создан
системным вызовом bind сначала удалим файл с этим именем в случае, если он сохранился от предыдущего запуска сервера.

-> 73 строка - вызов функции message_read, которая принимает от клиента сообщения, переводит их в верхний регистр и выводит на экран.

-> read:
Функция read делает попытку считать BUFFER_SIZE байт из файла, связанного с client_socket_descriptor, в message типа char. 

Возвращаемое значение:      
При успешном завершении возвращается положительное целое число, являющееся числом байт, помещенных в буфер;
По концу файла (EOF), функция возвращает нуль. При ошибке   функция   возвращает   значение   -1,   и
глобальной  переменной errno присваивается одно из следующих значений:
EACCES - Отказ доступа.
EBADF - Неверный номер файла.

-> 33 строка - Функция toupper() возвращает соответствующий верхнему регистру эквивалент символа ch, если ch — это буква. В противном случае ch возвращается
неизмененным.

-> close
close закрывает файловый дескриптор, который после этого не ссылается ни на один и файл и может быть использован повторно. 
УСПЕХ: 0
НЕУСПЕХ: -1
Ошибки:
EBADF - fd является неверным файловым дескриптором.
EINTR - Системный вызов close() был прерван сигналом.
EIO - Произошла ошибка ввода/вывода.



Закрываются сокеты так же, как и обычные дескрипторы файлового ввода/вывода, – при помощи системного вызова close. Для сокета типа SOCK_STREAM
ядро гарантирует, что все записанные в сокет данные будут переданы принимаю щему процессу. Если сокет имеет тип SOCK_DGRAM, то
сокет закрывается немедленно.

CLIENT:

СИСТЕМНЫЙ ВЫЗОВ CONNECT:
int connect (int sockfd, struct sockaddr *servaddr, int addrlen);
Назначение адреса для клиента также можно выполнить с помощью системного вызова connect() устанавливающего связь с сервером и автоматически связывающего сокет 
клиента с локальным коммуникационным узлом.  В этом случае клиенту нет необходимости явно связывать сокет с помощью системного вызова bind().
