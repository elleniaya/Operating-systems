ФАЙЛ В UNIX:
- Все данные пользователей хранятся в виде файлов
- Файлы определяют привилегии пользователей, поскольку права пользователя в большинстве случаев контролируются с помощью прав доступа к файлам.
- Файлы обеспечивают доступ к периферийным устройствам компьютера, включая диски, накопители на магнитной ленте, CD!ROM, принтеры, терминалы, сетевые 
адаптеры и даже память.
- Наконец, все программы, которые выполняются в системе, включая прикладные задачи пользователей, системные процессы и даже ядро UNIX, являются исполняемыми файлами.

(!) Для приложений UNIX доступ в дисковому файлу "неотличим" от доступа, скажем, к принтеру.

ФАЙЛОВАЯ СИСТЕМА:
Файлы организованы в виде древовидной структуры (дерева), называемой файловой системой.
Каждый файл имеет имя, определяющее его расположение в дереве файловой системы.
Корнем этого дерева является корневой каталог (root directory), имеющий имя "/".
Имена всех остальных файлов содержат путь — список каталогов (ветвей), которые необходимо пройти, чтобы достичь файла.

В UNIX все доступное пользователям файловое пространство объединено в единое дерево каталогов, корнем которого является каталог Таким образом, полное имя 
любого файла начинается с и не содержит идентификатора устройства (дискового накопителя, .. или удаленного компьютера в сети), на котором он фактически хранится.

В большинстве случаев единое дерево, такое каким его видит пользователь системы, составлено из нескольких отдельных файловых систем, которые могут иметь различную внутреннюю структуру, а файлы, принадлежащие этим файловым системам, могут быть расположены на различных устройствах.

СТРУКТУРА ФАЙЛА:
Имя файла является атрибутом файловой системы.

Каждый файл имеет связанные с ним метаданные (хранящиеся в индексных дескрипторах — inode), содержащие все характеристики файла и позволяющие операционной системе выполнять операции, заказанные прикладной задачей: открыть файл, прочитать или записать данные, создать или удалить файл. 

В частности, метаданные содержат указатели на дисковые блоки хранения данных файла. Имя файла в файловой системе является указателем на его метаданные, в то время как метаданные НЕ содержат указателя на имя файла.


ВЛАДЕЛЬЦЫ ФАЙЛОВ:
Файлы в UNIX имеют двух владельцев: пользователя (user owner) и группу (group owner).

-> Группой называется определенный список пользователей системы. Пользователь системы может быть членом нескольких групп, одна из которых является первичной (primary), 
остальные — дополнительными (supplementary).

Важной особенностью является то, что владелец пользователь может не являться членом группы, владеющей файлом. Это дает большую гибкость в организации доступа к файлам.

Владельцем-пользователем вновь созданного файла является пользователь, который создал файл. Порядок назначения владельца-группы зависит от
конкретной версии UNIX. Например, в SCO UNIX владельцем-группой является первичная группа пользователя, создавшего файл, а в Digital UNIX владелец-группа 
наследуется от владельца группы—каталога, в котором создается файл.

На самом деле файл создает не пользователь, а процесс, запущенный пользователем. Процесс имеет атрибуты, связанные с пользователем и группой, которые и назначаются файлу при его создании. Более точное описание передачи "владения" имеет вид:

1. Идентификатор владельца-пользователя файла (UID) устанавливается равным EUID процесса, создающего файл (т. е. вызвавшего функцию open(2) или creat(2)).
1. Идентификатор владельца-группы файла (group ID) устанавливается равным
а) EGID процесса (для версии System V);
б) GID каталога, в котором файл создается (для версии BSD).
Большинство систем, использующих наследование System V, позволяют также устанавливать наследование группового владельца в стиле BSD. Это достигается установкой флага
SGID на каталог. 

Владение файлом определяет тот набор операций, который пользователь может совершить с файлом.
Часть из них, такие как изменение прав доступа или владельца файла (табл. 1.1), может осуществлять только владелец (или суперпользователь (имеет UID = 0, что дает 
ему неограниченные права в системе)), другие операции, такие как чтение, запись и запуск на выполнение (для исполняемых файлов) дополнительно контролируются правами доступа.

ИЗМЕНЕНИЕ ВЛАДЕЛЬЦЕВ ФАЙЛА ИЛИ ГРУППЫ:
Для изменения владельца файла используется команда chown.

(!)  Например, следующая команда установит пользователя sergey владельцем файлов client.c server.c
$ sergey client.c server.c

Изменение владельца-группы производится командой chgrp.
Например, для установки группы staff в качестве владельца всех файлов текущего каталога, необходимо задать следующую команду:
$ chgrp staff *


...................................../то что надо сказать/..................................

ПРАВА ДОСТУПА К ФАЙЛУ:

Маска прав доступа в Unix представляет собой 12-разрядную битовую маску. Старшие 3 бита кодируют setuid, setgid и sticky-биты. Следующие 9 бит кодируют собственно права доступа. Биты с 9 по 7 кодируют права доступа хозяина файла, биты с 6 по 4 — права группы, младшие три бита с 3 по 1 — права всех остальных пользователей.  Старший бит в тройке кодирует право чтения, средний бит — право записи, младший бит — право исполнения. 
Порядок бит, кодирующих права, соответствует порядку символов, описывающих права, в выдаче команды ls -l и ряда других стандартных утилит Unix.  Так, запись -rw-r—r-- в выдаче ls -l соответствует битовой маске 0644 и означает, что хозяин имеет право чтения и записи, а группа и все остальные — только права чтения.

............................................................................
В операционной системе UNIX существуют три базовых КЛАССА доступа к
файлу, в каждом из которых установлены соответствующие права доступа:
User access (u) Для владельца-пользователя файла
Group access (g) Для членов группы, являющейся владельцем файла
Other access (о) Для остальных пользователей (кроме суперпользователя)
............................................................................
Каждый процесс имеет два пользовательских идентификатора: реальный и эффективный.
Реальный идентификатор соответствует идентификатору пользователя, запускающего программу, а эффективный идентификатору пользователя, владеющего программой.

Обычно реальный и эффективный идентификаторы процесса совпадают, но существует возможность дать процессу более широкие права, чем права пользователя, его запустившего.
Это можно сделать с помощью установки признака setuid на файле. Этот признак позволяет назначить права доступа исходя из прав доступа владельца файла, т.е. при запуске на выполнение файла с установленным setuid признаком, эффективный идентификатор процесса будет изменен на идентификатор владельца исполняемого файла.
Процесс, запустивший программу с suid-битом будет иметь эффективный идентификатор, отличный от реального либо до конца времени выполнения программы, либо до применения системного вызова setuid(2).
................................./другая формулировка/.............................
Атрибуты (или флаги) SUID и SGID позволяют изменить права пользователя при запуске на выполнение файла, имеющего эти атрибуты. При этом привилегии будут изменены (обычно расширены) лишь на время выполнения и только в отношении этой программы.

Обычно запускаемая программа получает права доступа к системным ресурсам на основе прав доступа пользователя, запустившего программу. Установка флагов SUID и SGID изменяет это правило, назначая права доступа исходя из прав доступа владельца файла.
...................................................................................
SETUID:
Функция int setuid(uid_t uid) изменяет эффективный идентификатор вызывающего процесса, если аргумент функции uid совпадает с реальным идентификатором пользователя.

Изменение идентификаторов пользователя и группы:

Существуют определенные правила, согласно которым изменяются идентификаторы. Рассмотрим их на примере идентификатора пользователя. (Все перечисленное ниже в равной степени относится и к идентификатору группы.)

->Если процесс обладает привилегиями суперпользователя, функция setuid устанавливает реальный и эффективный идентификаторы пользователя в соответствии с аргументом uid.
->Если процесс не обладает привилегиями суперпользователя, но аргумент uid совпадает с реальным идентификатором пользователя, то setuid изменяет только эффективный идентификатор. Реальный и сохраненный идентификаторы не меняются.
->Если ни одно из этих условий не соблюдено, setuid возвращает значение (–1) и записывает в переменную errno код ошибки EPERM.

GETUID и GETEUID:
getuid возвращает реальный идентификатор ID пользователя в текущем процессе.
geteuid возвращает эффективный идентификатор ID пользователя в текущем процессе.

Реальный ID соответствует ID пользователя, который вызвал процесс. Эффективный ID соответствует установленному setuid биту на исполняемом файле.  
...............................................................
Операционная система производит проверку прав доступа при создании, открытии (для чтения или записи), запуске на выполнение или удалении файла. 
В следующей последовательности: суперпользователь (проверок нет, сразу доступ разрешается) -> владелец файла (если требуемое право доступа определено, доступ
разрешается) -> пользователь, являющийся членом группы, которая является владельцем файла (аналогично владельцу файла) -> прочие пользователи (аналогично).
...............................................................
ПРАВА ДОСТУПА ДЛЯ КАТАЛОГОВ:
1) чтение - позволяет получать ТОЛЬКО имена файлов, находящихся в данном каталоге.

2) выполнение - получение доп. информации о файлах каталога (например, командой ls -l), переход в каталог (cd). Это же право нужно иметь для доступа 
ко всем каталогам на пути к указанному.
(!) Например, если вы установите право на выполнения для всех пользователей в одном из своих подкаталогов, он все равно останется недоступным, пока ваш домашний каталог не будет иметь такого же права.
(!) Права и х действуют независимо, право х для каталога не требует наличия права и наоборот.

3) запись - создание и удаление файлов в каталоге. 
Самое важное, что при этом не учитываются права доступа для самого файла. То есть для того, чтобы удалить некоторый файл из каталога, не обязательно иметь 
какие-либо права доступа к этому файлу, важно лишь иметь право на запись для каталога, в котором находится этот файл.

ДОПОЛНИТЕЛЬНЫЕ АТРИБУТЫ ФАЙЛА:
Установка атрибута Sticky bit для каталога позволяет установить дополнительную защиту файлов, находящихся в каталоге. Из такого каталога пользователь может удалить только файлы, которыми он владеет, или на которые он имеет явное право доступа на запись, даже при наличии права на запись в каталог. (пример - каталог /tmp)

ПРИМЕР:
В качестве примера использования этого свойства рассмотрим утилиту passwd
позволяющую пользователю изменить свой пароль. Очевидно,
что изменение пароля должно привести к изменению содержимого определенных системных файлов 
(файла пароля /etc/passwd или /etc/shadow, или базы данных пользователей, если используется 
дополнительная защита системы). Понятно, что предоставление права на запись в эти файлы
всем пользователям системы является отнюдь не лучшим решением. Установка SUID для программы 
(точнее, на файл — исполняемый файл утилиты позволяет изящно разрешить это
противоречие. Поскольку владельцем файла является суперпользователь (его имя в системе — root), 
то кто бы ни запустил утилиту passwd на выполнение, во время работы данной программы он временно
получает права суперпользователя, т. е. может производить запись в системные файлы, защищенные от остальных пользователей.
