 gcc -o lab28 lab28.c -lgen

-> FILE *fp[2];
FILE, запись в который будет стандартным вводом команды.
Родительский процесс пишет в стандартный ввод порождённого через fp[0] и читает его стандартный вывод из fp[1].

p2open, p2close - открывает и закрывает программные каналы для стандартных ввода и вывода команды

-> p2open(3G):
запускает в порожденном процессе shell-команду и устанавливает связь с
этим процессом через канал. Он предоставляет двунаправленную связь.

p2open(3G) разветвляется (т.е. вызывает fork(2)) и исполняет командную
строку, на  которую  указывает  терминал.  При  возврате,  fp[0]  содержит
указатель на FILE, запись в который будет стандартным вводом команды.
fp[1] содержит  указатель на файл, который может быть использован для
чтения стандартного вывода команды.

успех: pid подпроцесса
неуспех: -1 

-> sort -n
Сортирует числовые поля по арифметическому значению.
...............................................................
Если команда при закрытии входного потока только начинает обработку ввода, мы не можем
читать её вывод до закрытия её ввода. Если для закрытия ввода использовать pclose(3C), эта
функция будет ждать завершения команды. Но, поскольку мы ещё не начинали читать
вывод, команда может быть заблокирована из-за переполнения трубы на выходе. Таким
образом, и pclose(3C), и запущенная команда в такой ситуации могут никогда не
завершиться. В этой ситуации необходимо закрывать поток при помощи fclose(3C).

Как правило, нужно сначала закрывать поток ввода команды вызовом fclose(3C), потом
считывать данные из потока вывода команды и только потом закрывать этот поток вызовом
pclose(3C).
В этой программе важно, что  родитель делает  fclose(3S) для  того файла,  в который он
писал, так  что команда  sort(1) исполняющаяся  в подпроцессе,  увидит конец файла.

-> pclose(): 
Аргументы: указатель на FILE
Главное отличие pclose(3) от fclose(3) состоит в том, что pclose(3) ожидает завершения созданного процесса.
Запоминание pid созданного процесса в разных системах осуществляется по разному;  В Solaris библиотека создаёт отдельный
список pid, ассоциированных со структурами FILE.
УСПЕХ: выходной статус команды, когда она завершается. 
НЕУСПЕХ: -1 и установливается errno, чтобы указать на ошибку (ECHILD - Не удалось получить статус дочернего процесса).
Функция pclose(3) использует close(2), чтобы закрыть канал, и waitid(2) или waitpid(2) для того, чтобы дождаться завершения порождённого процесса.
Если бы pclose () возвращался до завершения дочернего процесса, у приложения не было бы возможности обнаружить, какой дочерний элемент раньше был связан с потоком, 
и оно не могло бы выполнить очистку самостоятельно.
...............................................................
-> srand():
Функция srand() используется для установки начала последовательности, генерируемой функцией rand() (функция rand() возвращает псевдослучайные числа).
Функция srand() позволяет запускать программу несколько раз с различными последовательностями псевдослучайных чисел.

Сочетание srand(time(NULL)) устанавливает в качестве базы текущее время.

-> fileno:
Функция fileno() определяет дескриптор файла открытого потока данных по указателю на управляющую таблицу потока данных.
Возвращаемое значение:
Дескриптор файла (целое положительное число) при успешном завершении работы функции.
-1, если при определении дескриптора файла произошли ошибки.

-> read:
Функция read делает попытку считать 1 байт из файла, связанного с fileno(fp[1]), в переменную с типа char. 
В файле, открытом в текстовом режиме, функция read удаляет символы "возврат каретки" и выдает "конец
файла" (EOF), при достижении символа Ctrl-Z.

Возвращаемое значение:      
При успешном завершении возвращается положительное целое число, являющееся числом байт, помещенных
в буфер;
По концу файла (EOF), функция возвращает нуль. При ошибке   функция   возвращает   значение   -1,   и
глобальной  переменной errno присваивается одно из следующих значений:
EACCES - Отказ доступа.
EBADF - Неверный номер файла.

-> Если буфер канала пуст, но файловый дескриптор другого конца
ещё открыт, read(2) будет заблокирован. Это поведение может быть изменено флагами
O_NONBLOCK и O_NDELAY

-> write:
write () записывает количество байтов из буфера, начиная с buf, в файл, на который ссылается файловый дескриптор fd.
В случае успеха возвращается количество записанных байтов. При ошибке, возвращается -1, а errno указывает на ошибку.

КАНАЛЫ:
Программные каналы - это линии связи между двумя или более процессами. По традиции, прикладные программы используют каналы следующим образом: один процесс пишет дан
ные в канал, а другой читает их оттуда. В SVR4 каналы стали двунаправленным механизмом, так что два процесса могут передавать информацию в обоих направлениях через
один программный канал.

Существует два типа программных каналов: неименованные, часто называемые просто трубами, и именованные каналы. 

(!) Главное преимущество именованных каналов над обычными состоит в том, что их могут использовать неродственные процессы.

(!) Процессы не обязаны заботиться о переполнении канала избытком данных или о невозможности читать из пустого канала. В канальный механизм встроена синхронизация 
между читающим и пишущим процессами: пишущий процесс блокируется, т.е. приостанавливает исполнение, при попытке записи в переполненный канал, и, соответственно, 
читающий процесс останавливается при попытке чтения из пустого канала.

(!) Канал идентифицируется таким же файловым дескриптором, как и открытые обычные и специальные файлы. 

Многие стандартные утилиты Unix, такие, как sort(1), grep(1), sed(1), gzip(1) представляют собой «фильтры», то есть программы, последовательно обрабатывающие поток
данных на вводе и преобразующие его в поток данных на выводе. Такие программы могут работать с терминалом, регулярными файлами, многими типами устройств и
программными каналами, не замечая различий.

КАК ЧИТАЮТСЯ И ЗАПИСЫВАЮТСЯ В КАНАЛ:
Данные пишутся в канал так же, как и в обычный файл, при помощи системного вызова write(2). Как упоминалось выше, если канал не имеет места для записи всех данных,
write(2) останавливается. Система не допускает частичной записи: write(2) блокируется до момента, пока все данные не будут записаны, либо пока не будет обнаружена
ошибка.

Данные читаются из канала при помощи системного вызова read(2). В отличие от обычных файлов, чтение разрушает данные в канале. Это означает, что вы не можете
использовать lseek(2) для попыток прочитать данные заново.

Если процесс пытается писать в канал, из которого никто не читает, он получит сигнал SIGPIPE.

....................................................
Почему каналы лучше обмена данными через файл?
Программные каналы, в отличие от регулярных файлов, представляют собой непрерывный поток байтов, по которому может быть передано произвольно большое количество
информации. При этом собственная ёмкость канала очень невелика.
Основная проблема, возникающая при обмене информацией через обычный файл – это отсутствие синхронизации. Если предположить, что ёмкость файла не является проблемой,
как читающий процесс узнает, что пишущий процесс окончил запись? Использование сигналов для этой цели — неудовлетворительное решение.
....................................................
/////////////////////////////////////////////////////////////////////////
-> p2close(3G):
p2close(3G) закрывает  оба указателя  на FILE.  Если программист хочет
закрыть  один   из  потоков,  он  может  использовать  для  этой  цели
fclose(3S).  Это  необходимо,  если  команда  является  фильтром,  как
sort(1), который  должен увидеть  конец файла  перед тем,  как  начать
обработку ввода.

успех: статус подпроцесса
неуспех: -1
/////////////////////////////////////////////////////////////////////////
Системный вызов pipe:
Программные каналы создаются системным вызовом pipe(2)

Системный вызов pipe(2) заполняет массив целых чисел двумя дескрипторами файлов. В
ранних версиях системы первый элемент массива содержал дескриптор, связанный с концом
канала, предназначенным для чтения; второй - для записи. В SVR4 оба дескриптора открыты
для чтения и записи, позволяя двусторонний обмен данными.

Как правило, программные каналы используются следующим образом: после системного
вызова pipe(2), создавшего программный канал, вызовом fork(2) создаётся подпроцесс. Затем
родительский и порождённый процессы закрывают тот из концов канала, который не
собираются использовать. Родительский процесс может также создать два подпроцесса,
каждый из которых закроет ненужный ему конец программного канала. Если родитель не
хочет взаимодействовать с порождёнными им процессами, он должен закрыть оба конца
канала.

Неиспользуемые файловые дескрипторы необходимо закрывать потому, что программный
канал выдаёт условие конца файла только когда его пишущий конец закрыт. При fork(2)
происходит дублирование файлового дескриптора, а программный канал считается
закрытым только когда будут закрыты все копии связанного с этим каналом дескриптора.
Если вы забудете закрыть один из дескрипторов, процесс, ожидающий конец файла в канале
(возможно, ваш же собственный процесс!), никогда его не дождётся.
